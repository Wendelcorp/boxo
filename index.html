<!DOCTYPE html>
<html>
<head>
    <title>BOXO</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Mobile scaling -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Poppins', sans-serif;
            color: #3375BB;
            text-align: center;
            background-color: #FEC569;
            margin: 0;
            padding: 0;
        }

        h1 {
            margin-top: 20px;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }

        /* Grid Styles */
        #grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 5px;
            width: 90vw; /* Responsive width */
            max-width: 400px;
            margin-bottom: 20px;
        }

        .grid-square {
            background-color: #C2DFF5;
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* Square aspect ratio */
            overflow: hidden;
            border: 4px solid #3375BB;
            box-sizing: border-box;
        }

        .grid-square-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 5vw; /* Responsive font size */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Tiles Styles */
        #tiles-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .tile {
            position: relative;
            width: 20vw;
            max-width: 80px;
            margin: 5px;
            padding-bottom: 20vw; /* Square aspect ratio */
            background-color: #F7A5AC;
            border: 3px solid #3375BB;
            cursor: grab;
            box-sizing: border-box;
            overflow: hidden;
            touch-action: none; /* Prevent default touch actions */
        }

        .tile:active {
            cursor: grabbing;
        }

        .tile-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 6vw; /* Responsive font size */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-weight: bolder;
            user-select: none;
        }

        .letter-left {
            position: relative;
            top: -10%;
        }

        .letter-right {
            position: relative;
            bottom: -10%;
        }

        /* Buttons */
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .buttons button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 4vw; /* Responsive font size */
            max-font-size: 16px;
            cursor: pointer;
        }

        /* Message */
        #message {
            font-size: 5vw; /* Responsive font size */
            max-font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        /* Responsive Adjustments */
        @media (min-width: 600px) {
            .grid-square-content {
                font-size: 24px;
            }

            .tile-content {
                font-size: 32px;
            }

            .buttons button {
                font-size: 16px;
            }

            #message {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <h1>BOXO</h1>
    <div id="game-container">
        <div id="level-indicator">Level 1</div>
        <div id="tiles-container"></div>
        <div id="grid"></div>
        <div class="buttons">
            <button id="reset-button">Reset</button>
            <button id="hint-button">Hint</button>
            <button id="next-level-button" disabled>Next Level</button>
        </div>
        <div id="message"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const levels = {
                1: ["List", "Step", "Keep", "Like"],
                2: ["Sore", "Rely", "Only", "Soon"],
                3: ["Note", "Text", "Next", "None"],
                4: ["Wish", "Shed", "Need", "Wine"],
                5: ["Dare", "Rest", "Test", "Date"],
                // Add more levels as needed
            };

            let currentLevel = 1;
            let tiles = [];
            let targetWords = {};
            let correctPositions = {};
            let draggedTile = null;

            const gridContainer = document.getElementById('grid');
            const tilesContainer = document.getElementById('tiles-container');
            const resetButton = document.getElementById('reset-button');
            const hintButton = document.getElementById('hint-button');
            const nextLevelButton = document.getElementById('next-level-button');
            const messageDiv = document.getElementById('message');
            const levelIndicator = document.getElementById('level-indicator');

            function initLevel(level) {
                // Clear previous tiles and grid
                tilesContainer.innerHTML = '';
                gridContainer.innerHTML = '';
                messageDiv.textContent = '';
                nextLevelButton.disabled = true;
                levelIndicator.textContent = `Level ${level}`;

                // Get words for the level
                const levelWords = levels[level];
                if (!levelWords) {
                    messageDiv.textContent = 'No more levels!';
                    return;
                }

                // Map words to their positions
                targetWords = {
                    leftColumn: levelWords[0].toUpperCase(),
                    bottomRow: levelWords[1].toUpperCase(),
                    rightColumn: levelWords[2].toUpperCase(),
                    topRow: levelWords[3].toUpperCase()
                };

                // Generate tiles and correct positions
                generateTilesAndPositions();

                // Create grid squares
                createGridSquares();

                // Shuffle the tiles after they are added to the container
                shuffleDivs();

                // Add event listeners to tiles and buttons
                addEventListeners();
            }

            function generateTilesAndPositions() {
                // Extract letters to create tiles
                const tileLetters = {};

                // Tiles are positions: tile00, tile01, tile10, tile11
                const tile00 = [
                    targetWords.topRow[0],
                    targetWords.topRow[1]
                ];

                const tile01 = [
                    targetWords.topRow[2],
                    targetWords.topRow[3]
                ];

                const tile10 = [
                    targetWords.bottomRow[0],
                    targetWords.bottomRow[1]
                ];

                const tile11 = [
                    targetWords.bottomRow[2],
                    targetWords.bottomRow[3]
                ];

                // Verify that letters match for vertical words
                const leftColumnCheck = tile00[0] + tile00[1] + tile10[0] + tile10[1] === targetWords.leftColumn;
                const rightColumnCheck = tile01[0] + tile01[1] + tile11[0] + tile11[1] === targetWords.rightColumn;

                if (!leftColumnCheck || !rightColumnCheck) {
                    messageDiv.textContent = 'Error: Words do not form a valid grid.';
                    return;
                }

                // Store tile letters
                tileLetters['tile00'] = tile00;
                tileLetters['tile01'] = tile01;
                tileLetters['tile10'] = tile10;
                tileLetters['tile11'] = tile11;

                // Create tiles
                tiles = [];
                for (let key in tileLetters) {
                    const letters = tileLetters[key];
                    const tileId = `tile-${letters.join('')}`;
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.id = tileId;
                    tile.dataset.letters = letters.join(',');

                    const tileContent = document.createElement('div');
                    tileContent.classList.add('tile-content');

                    // Create span elements for letters
                    const spanLeft = document.createElement('div');
                    spanLeft.classList.add('letter-left');
                    spanLeft.textContent = letters[0];

                    const spanRight = document.createElement('div');
                    spanRight.classList.add('letter-right');
                    spanRight.textContent = letters[1];

                    tileContent.appendChild(spanLeft);
                    tileContent.appendChild(spanRight);

                    tile.appendChild(tileContent);
                    tilesContainer.appendChild(tile);
                    tiles.push(tile);
                }

                // Correct positions for hint function
                correctPositions = {
                    [`tile-${tile00.join('')}`]: '0-0',
                    [`tile-${tile01.join('')}`]: '0-1',
                    [`tile-${tile10.join('')}`]: '1-0',
                    [`tile-${tile11.join('')}`]: '1-1'
                };
            }

            function createGridSquares() {
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 2; col++) {
                        const square = document.createElement('div');
                        square.classList.add('grid-square');
                        square.dataset.position = `${row}-${col}`;

                        const squareContent = document.createElement('div');
                        squareContent.classList.add('grid-square-content');
                        square.appendChild(squareContent);

                        gridContainer.appendChild(square);

                        // Add event listener for drop functionality
                        square.addEventListener('drop', handleDrop);
                        square.addEventListener('dragover', handleDragOver);
                        square.addEventListener('touchend', handleDrop);
                    }
                }
            }

            function addEventListeners() {
                tiles.forEach(tile => {
                    // Drag-and-Drop Events
                    tile.addEventListener('dragstart', handleDragStart);
                    tile.addEventListener('dragend', handleDragEnd);

                    // Touch Events
                    tile.addEventListener('touchstart', handleTouchStart);
                    tile.addEventListener('touchmove', handleTouchMove);
                    tile.addEventListener('touchend', handleTouchEnd);
                });

                resetButton.addEventListener('click', () => {
                    resetGame();
                });

                hintButton.addEventListener('click', () => {
                    provideHint();
                });

                nextLevelButton.addEventListener('click', () => {
                    currentLevel++;
                    initLevel(currentLevel);
                });
            }

            // Drag-and-Drop Handlers
            function handleDragStart(e) {
                draggedTile = this;
                setTimeout(() => {
                    this.classList.add('invisible');
                }, 0);
            }

            function handleDragEnd() {
                this.classList.remove('invisible');
            }

            function handleDragOver(e) {
                e.preventDefault();
            }

            function handleDrop(e) {
                e.preventDefault();
                const squareContent = this.querySelector('.grid-square-content');
                if (squareContent.children.length === 0 && draggedTile) {
                    squareContent.appendChild(draggedTile);
                    checkCompletion();
                    draggedTile = null;
                }
            }

            // Touch Handlers
            function handleTouchStart(e) {
                e.preventDefault();
                draggedTile = this;
                this.classList.add('invisible');

                const touch = e.touches[0];
                draggedTile.initialX = touch.clientX - draggedTile.offsetLeft;
                draggedTile.initialY = touch.clientY - draggedTile.offsetTop;
            }

            function handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const x = touch.clientX - draggedTile.initialX;
                const y = touch.clientY - draggedTile.initialY;

                draggedTile.style.position = 'absolute';
                draggedTile.style.left = `${x}px`;
                draggedTile.style.top = `${y}px`;
            }

            function handleTouchEnd(e) {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY);

                if (dropTarget && dropTarget.classList.contains('grid-square-content')) {
                    if (dropTarget.children.length === 0) {
                        dropTarget.appendChild(draggedTile);
                        checkCompletion();
                    } else {
                        // Return tile to tiles container if drop target is occupied
                        tilesContainer.appendChild(draggedTile);
                    }
                } else {
                    // Return tile to tiles container if not dropped on a grid square
                    tilesContainer.appendChild(draggedTile);
                }

                // Reset tile styles
                draggedTile.style.position = '';
                draggedTile.style.left = '';
                draggedTile.style.top = '';
                draggedTile.classList.remove('invisible');
                draggedTile = null;
            }

            function checkCompletion() {
                const positions = {};
                const gridSquares = document.querySelectorAll('.grid-square');
                gridSquares.forEach(square => {
                    const pos = square.dataset.position;
                    const squareContent = square.querySelector('.grid-square-content');
                    if (squareContent.children.length > 0) {
                        const tile = squareContent.children[0];
                        positions[pos] = tile.dataset.letters.split(',');
                    }
                });

                if (Object.keys(positions).length === 4) {
                    // All squares are filled
                    const isSolved = checkArrangement(positions);

                    if (isSolved) {
                        messageDiv.textContent = 'Congratulations! You solved the puzzle!';
                        nextLevelButton.disabled = false;
                    } else {
                        messageDiv.textContent = 'Not quite right. Try again!';
                    }
                } else {
                    messageDiv.textContent = '';
                }
            }

            function checkArrangement(positions) {
                // First arrangement (original)
                const tile00 = positions['0-0'];
                const tile01 = positions['0-1'];
                const tile10 = positions['1-0'];
                const tile11 = positions['1-1'];

                const topRowWord = tile00[0] + tile00[1] + tile01[0] + tile01[1];
                const bottomRowWord = tile10[0] + tile10[1] + tile11[0] + tile11[1];
                const leftColumnWord = tile00[0] + tile00[1] + tile10[0] + tile10[1];
                const rightColumnWord = tile01[0] + tile01[1] + tile11[0] + tile11[1];

                return (
                    (topRowWord === targetWords.topRow &&
                    bottomRowWord === targetWords.bottomRow &&
                    leftColumnWord === targetWords.leftColumn &&
                    rightColumnWord === targetWords.rightColumn) ||

                    // Check for alternative arrangement (if applicable)
                    (topRowWord === targetWords.leftColumn &&
                    bottomRowWord === targetWords.rightColumn &&
                    leftColumnWord === targetWords.topRow &&
                    rightColumnWord === targetWords.bottomRow)
                );
            }

            function resetGame() {
                // Remove tiles from grid squares
                const gridSquares = document.querySelectorAll('.grid-square-content');
                gridSquares.forEach(squareContent => {
                    if (squareContent.children.length > 0) {
                        const tile = squareContent.children[0];
                        squareContent.removeChild(tile);
                        tilesContainer.appendChild(tile);
                    }
                });
                messageDiv.textContent = '';
                draggedTile = null;
                nextLevelButton.disabled = true;
                shuffleDivs();
            }

            function provideHint() {
                // Check which tiles are not yet placed
                const unplacedTiles = Array.from(tiles).filter(tile => !tile.closest('.grid-square'));
                // If​⬤