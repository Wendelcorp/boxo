<!DOCTYPE html>
<html>
<head>
    <title>BOXO</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- Mobile scaling -->
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Poppins', sans-serif;
            color: #3375BB;
            text-align: center;
            background-color: #FEC569;
            margin: 0;
            padding: 0;
        }

        h1 {
            margin-top: 20px;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }

        /* Grid Styles */
        #grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-gap: 5px;
            width: 90vw; /* Responsive width */
            max-width: 400px;
            margin-bottom: 20px;
        }

        .grid-square {
            background-color: #C2DFF5;
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* Square aspect ratio */
            overflow: hidden;
        }

        .grid-square-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 4px solid #3375BB;
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5vw; /* Responsive font size */
        }

        /* Tiles Styles */
        #tiles-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .tile {
            position: relative;
            width: 20vw;
            max-width: 80px;
            margin: 5px;
            padding-bottom: 20vw; /* Square aspect ratio */
            background-color: #F7A5AC;
            border: 3px solid #3375BB;
            cursor: pointer;
            box-sizing: border-box;
            overflow: hidden;
        }

        .tile-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            font-size: 6vw; /* Responsive font size */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            font-weight: bolder;
        }

        .tile.selected {
            outline: 4px solid #FFD700;
        }

        .letter-left {
            position: relative;
            top: -10%;
        }

        .letter-right {
            position: relative;
            bottom: -10%;
        }

        /* Buttons */
        .buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 20px;
        }

        .buttons button {
            margin: 5px;
            padding: 10px 20px;
            font-size: 4vw; /* Responsive font size */
            max-font-size: 16px;
            cursor: pointer;
        }

        /* Message */
        #message {
            font-size: 5vw; /* Responsive font size */
            max-font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        /* Responsive Adjustments */
        @media (min-width: 600px) {
            .grid-square-content {
                font-size: 24px;
            }

            .tile-content {
                font-size: 32px;
            }

            .buttons button {
                font-size: 16px;
            }

            #message {
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <h1>BOXO</h1>
    <div id="game-container">
        <div id="level-indicator">Level 1</div>
        <div id="tiles-container"></div>
        <div id="grid"></div>
        <div class="buttons">
            <button id="reset-button">Reset</button>
            <button id="hint-button">Hint</button>
            <button id="next-level-button" disabled>Next Level</button>
        </div>
        <div id="message"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const levels = {
                1: ["List", "Step", "Keep", "Like"],
                2: ["Sore", "Rely", "Only", "Soon"],
                3: ["Note", "Text", "Next", "None"],
                4: ["Wish", "Shed", "Need", "Wine"],
                5: ["Dare", "Rest", "Test", "Date"],
                // Add more levels as needed
            };

            let currentLevel = 1;
            let tiles = [];
            let targetWords = {};
            let correctPositions = {};
            let selectedTile = null;

            const gridContainer = document.getElementById('grid');
            const tilesContainer = document.getElementById('tiles-container');
            const resetButton = document.getElementById('reset-button');
            const hintButton = document.getElementById('hint-button');
            const nextLevelButton = document.getElementById('next-level-button');
            const messageDiv = document.getElementById('message');
            const levelIndicator = document.getElementById('level-indicator');

            function initLevel(level) {
                // Clear previous tiles and grid
                tilesContainer.innerHTML = '';
                gridContainer.innerHTML = '';
                messageDiv.textContent = '';
                nextLevelButton.disabled = true;
                levelIndicator.textContent = `Level ${level}`;

                // Get words for the level
                const levelWords = levels[level];
                if (!levelWords) {
                    messageDiv.textContent = 'No more levels!';
                    return;
                }

                // Map words to their positions
                targetWords = {
                    leftColumn: levelWords[0].toUpperCase(),
                    bottomRow: levelWords[1].toUpperCase(),
                    rightColumn: levelWords[2].toUpperCase(),
                    topRow: levelWords[3].toUpperCase()
                };

                // Generate tiles and correct positions
                generateTilesAndPositions();

                // Create grid squares
                createGridSquares();

                // Shuffle the tiles after they are added to the container
                shuffleDivs();

                // Add event listeners to tiles and buttons
                addEventListeners();
            }

            function generateTilesAndPositions() {
                // Extract letters to create tiles
                const tileLetters = {};

                // Tiles are positions: tile00, tile01, tile10, tile11
                const tile00 = [
                    targetWords.topRow[0],
                    targetWords.topRow[1]
                ];

                const tile01 = [
                    targetWords.topRow[2],
                    targetWords.topRow[3]
                ];

                const tile10 = [
                    targetWords.bottomRow[0],
                    targetWords.bottomRow[1]
                ];

                const tile11 = [
                    targetWords.bottomRow[2],
                    targetWords.bottomRow[3]
                ];

                // Verify that letters match for vertical words
                const leftColumnCheck = tile00[0] + tile00[1] + tile10[0] + tile10[1] === targetWords.leftColumn;
                const rightColumnCheck = tile01[0] + tile01[1] + tile11[0] + tile11[1] === targetWords.rightColumn;

                if (!leftColumnCheck || !rightColumnCheck) {
                    messageDiv.textContent = 'Error: Words do not form a valid grid.';
                    return;
                }

                // Store tile letters
                tileLetters['tile00'] = tile00;
                tileLetters['tile01'] = tile01;
                tileLetters['tile10'] = tile10;
                tileLetters['tile11'] = tile11;

                // Create tiles
                tiles = [];
                for (let key in tileLetters) {
                    const letters = tileLetters[key];
                    const tileId = `tile-${letters.join('')}`;
                    const tile = document.createElement('div');
                    tile.classList.add('tile');
                    tile.id = tileId;
                    tile.dataset.letters = letters.join(',');

                    const tileContent = document.createElement('div');
                    tileContent.classList.add('tile-content');

                    // Create span elements for letters
                    const spanLeft = document.createElement('div');
                    spanLeft.classList.add('letter-left');
                    spanLeft.textContent = letters[0];

                    const spanRight = document.createElement('div');
                    spanRight.classList.add('letter-right');
                    spanRight.textContent = letters[1];

                    tileContent.appendChild(spanLeft);
                    tileContent.appendChild(spanRight);

                    tile.appendChild(tileContent);
                    tilesContainer.appendChild(tile);
                    tiles.push(tile);
                }

                // Correct positions for hint function
                correctPositions = {
                    [`tile-${tile00.join('')}`]: '0-0',
                    [`tile-${tile01.join('')}`]: '0-1',
                    [`tile-${tile10.join('')}`]: '1-0',
                    [`tile-${tile11.join('')}`]: '1-1'
                };
            }

            function createGridSquares() {
                for (let row = 0; row < 2; row++) {
                    for (let col = 0; col < 2; col++) {
                        const square = document.createElement('div');
                        square.classList.add('grid-square');
                        square.dataset.position = `${row}-${col}`;

                        const squareContent = document.createElement('div');
                        squareContent.classList.add('grid-square-content');
                        square.appendChild(squareContent);

                        gridContainer.appendChild(square);

                        // Add event listener for tap-to-place functionality
                        square.addEventListener('click', () => {
                            if (selectedTile && squareContent.children.length === 0) {
                                squareContent.appendChild(selectedTile);
                                selectedTile.classList.remove('selected');
                                selectedTile = null;
                                checkCompletion();
                            }
                        });
                    }
                }
            }

            function addEventListeners() {
                tiles.forEach(tile => {
                    // Add event listener for tap-to-select functionality
                    tile.addEventListener('click', () => {
                        // Deselect if the same tile is clicked
                        if (selectedTile === tile) {
                            tile.classList.remove('selected');
                            selectedTile = null;
                        } else {
                            // Deselect previous tile
                            if (selectedTile) {
                                selectedTile.classList.remove('selected');
                            }
                            // Select new tile
                            selectedTile = tile;
                            tile.classList.add('selected');
                        }
                    });
                });

                resetButton.addEventListener('click', () => {
                    resetGame();
                });

                hintButton.addEventListener('click', () => {
                    provideHint();
                });

                nextLevelButton.addEventListener('click', () => {
                    currentLevel++;
                    initLevel(currentLevel);
                });
            }

            function checkCompletion() {
                const positions = {};
                const gridSquares = document.querySelectorAll('.grid-square');

                gridSquares.forEach(square => {
                    const pos = square.dataset.position;
                    const squareContent = square.querySelector('.grid-square-content');
                    if (squareContent.children.length > 0) {
                        const tile = squareContent.children[0];
                        positions[pos] = tile.dataset.letters.split(',');
                    }
                });

                if (Object.keys(positions).length === 4) {
                    // All squares are filled
                    const isSolved = checkArrangement(positions);

                    if (isSolved) {
                        messageDiv.textContent = 'Congratulations! You solved the puzzle!';
                        nextLevelButton.disabled = false;
                    } else {
                        messageDiv.textContent = 'Not quite right. Try again!';
                    }
                } else {
                    messageDiv.textContent = '';
                }
            }

            function checkArrangement(positions) {
                // First arrangement (original)
                const tile00 = positions['0-0'];
                const tile01 = positions['0-1'];
                const tile10 = positions['1-0'];
                const tile11 = positions['1-1'];

                const topRowWord = tile00[0] + tile00[1] + tile01[0] + tile01[1];
                const bottomRowWord = tile10[0] + tile10[1] + tile11[0] + tile11[1];
                const leftColumnWord = tile00[0] + tile00[1] + tile10[0] + tile10[1];
                const rightColumnWord = tile01[0] + tile01[1] + tile11[0] + tile11[1];

                return (
                    (topRowWord === targetWords.topRow &&
                    bottomRowWord === targetWords.bottomRow &&
                    leftColumnWord === targetWords.leftColumn &&
                    rightColumnWord === targetWords.rightColumn) ||

                    // Check for alternative arrangement (if applicable)
                    (topRowWord === targetWords.leftColumn &&
                    bottomRowWord === targetWords.rightColumn &&
                    leftColumnWord === targetWords.topRow &&
                    rightColumnWord === targetWords.bottomRow)
                );
            }

            function resetGame() {
                // Remove tiles from grid squares
                const gridSquares = document.querySelectorAll('.grid-square-content');
                gridSquares.forEach(squareContent => {
                    if (squareContent.children.length > 0) {
                        const tile = squareContent.children[0];
                        squareContent.removeChild(tile);
                        tilesContainer.appendChild(tile);
                    }
                });
                messageDiv.textContent = '';
                selectedTile = null;
                nextLevelButton.disabled = true;
                tiles.forEach(tile => tile.classList.remove('selected'));
                shuffleDivs();
            }

            function provideHint() {
                // Check which tiles are not yet placed
                const unplacedTiles = Array.from(tiles).filter(tile => !tile.closest('.grid-square'));
                // If there are unplaced tiles, place one of them correctly
                if (unplacedTiles.length > 0) {
                    for (let tile of unplacedTiles) {
                        const tileId = tile.id;
                        const pos = correctPositions[tileId];
                        const square = document.querySelector(`.grid-square[data-position="${pos}"] .grid-square-content`);
                        if (square.children.length === 0) {
                            square.appendChild(tile);
                            tile.classList.remove('selected');
                            selectedTile = null;
                            checkCompletion();
                            break;
                        }
                    }
                }
            }

            function shuffleDivs() {
                const parent = document.getElementById('tiles-container');
                const divsArray = Array.from(parent.children);

                // Fisher-Yates shuffle algorithm to randomize array
                for (let i = divsArray.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [divsArray[i], divsArray[j]] = [divsArray[j], divsArray[i]];
                }

                // Append shuffled divs back to parent
                divsArray.forEach(div => parent.appendChild(div));
            }

            // Initialize the first level
            initLevel(currentLevel);
        });
    </script>
</body>
</html>